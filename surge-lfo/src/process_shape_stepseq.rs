crate::ix!();

impl Lfo {

    /// Depending on the value of `deform`, different
    /// calculations are performed to generate
    /// a waveform, which is then assigned to the
    /// `iout` field of the `Lfo` struct.
    /// 
    /// The function uses several helper functions and
    /// fields that are defined elsewhere in the code,
    /// including `pvalf!`, `cubic_interpolate`,
    /// `FloatOrd`, `phase`, and `wf_history`.
    ///
    #[inline] pub fn process_shape_stepseq(&mut self) {

        let deform: f32 = 
            pvalf![self.params[LfoParam::Deform]];

        let phase = self.phase;

        match deform {

            // If `deform` is greater than 0.5,
            // a waveform is generated by
            // combining a linear interpolation
            // and a cubic interpolation of the
            // previous waveform values. 
            //
            // The `iout` field is assigned the
            // result of this calculation.
            //
            deform if deform > 0.5 => {

                let wf0 = self.wf_history[0];
                let wf1 = self.wf_history[1];
                let wf2 = self.wf_history[2];
                let wf3 = self.wf_history[3];

                let linear: f32 = (1.0 - phase) * wf2 + phase * wf1;

                let cubic: f32 = cubic_interpolate(wf3, wf2, wf1, wf0, phase);

                self.iout = {

                    let deform2 = 2.0 * deform;

                    let x0 = 2.0 - deform2;
                    let x1 = deform2 - 1.0;

                    x0 * linear + x1 * cubic
                };
            },

            // If `deform` is between
            // 0 (inclusive) and -0.0001
            // (exclusive), a waveform is
            // generated using linear
            // interpolation of the previous
            // waveform values. 
            //
            // The `iout` field is assigned the
            // result of this calculation.
            //
            deform if deform > -0.0001 => {

                let deform2 = 2.0 * deform;

                let x0 = phase / (deform2 + 0.00001);

                let cf: f32 = clamp(x0, 0.0, 1.0);

                let wf1 = self.wf_history[1];
                let wf2 = self.wf_history[2];

                self.iout = (1.0 - cf) * wf2 + cf * wf1;

            },

            // If `deform` is between -0.0001
            // (inclusive) and -0.5 (exclusive),
            // a waveform is generated by
            // linearly interpolating between
            // 0 and the previous waveform value. 
            //
            // The `iout` field is assigned the
            // result of this calculation.
            //
            deform if deform > -0.5 => {

                let wf1 = self.wf_history[1];

                let x0 = (1.0 - phase) / (-2.0 * deform + 0.00001);

                let cf: f32 = clamp(x0, 0.0, 1.0);

                self.iout = (1.0 - cf) * 0.0 + cf * wf1;
            },

            // If `deform` is less than or equal
            // to -0.5, a waveform is generated
            // by linearly interpolating between
            // 0 and the current waveform value. 
            //
            // The `iout` field is assigned the
            // result of this calculation.
            //
            _ => {

                let x0 = phase / (2.0 + 2.0 * deform + 0.00001);

                let cf: f32 = clamp(x0, 0.0, 1.0);

                let wf1 = self.wf_history[1];

                self.iout = (1.0 - cf) * wf1 + cf * 0.0;
            },
        }
    }
}
